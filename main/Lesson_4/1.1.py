# Анонимные, lambda-функции
def f(x)
    return x ** 2
print(f(2))

# Какой тип данных у функции? → <class “function”>
# У функции есть тип, значит мы можем создать переменную типа функции и
# положить в эту переменную какую-то другую функцию.

def f(x)
    return x ** 2
g = f

# Теперь в контексте этого приложения g может использоваться точно так же, как и f.
# g — это переменная, которая хранит в себе ссылку на функцию.

def f(x)
    return x ** 2
g = f
print(f(4)) # 16
print(g(4)) # 16

# Зачем это может потребоваться?

# Есть некая функция calc, которая принимает в качестве аргумента число, а в
# качестве результата возвращает это число + 10:

def calc1(x)
    return x + 10
print(calc1(10)) # 20


def calc2(x)
    return x * 10
def math(op, x)
print(op, x)
math(calc2, 10) # 100

# Попробуем описать ту же логику для функции с двумя переменными.
# op — операция, воспринимаем её как отдельную функцию. В примере это либо
# сумма (sum), либо перемножение(mylt):

def sum(x, y):  
    return x + y
def mylt(x, y):
    return x * y

def calc(op, a, b):
    print(op(a, b))

calc(mylt, 4, 5) # 20

#Можно создать псевдоним для функции сложения (f).

def sum(x, y):
    return x + y
f = sum
calc(f, 4, 5) # 9

# В Python есть механизм, который позволяет превратить подобный вызов во что-то
# более красивое — lambda.

def sum(x, y):
    return x + y

# ⇔ (равносильно)

sum = lambda x, y: x + y

# Теперь, чтобы вызвать функцию суммы, достаточно просто вызвать sum.
# Также можно пропустить шаг создания переменной sum и сразу вызвать lambda:

calc(lambda x, y: x + y, 4, 5) # 9




